/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstring>

using std::cout, std::cin, std::string;

#define MAX_WORD_LENGTH 40

int main()
{
    /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|     
     *                 / |3  3  3 |     
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     */
    {
        int nums [3][3][3] = {
        {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
        {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}},
        {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}};
/**
 * Задание 1.2.
 *
 * Объявите неинициализированный массив и присвойте значения элементам с
 * помощью кода так, чтобы в итоге получился такой же массив, как в задании
 * 1.1.
 */
        int nums2 [3][3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                for (int h = 0; h < 3; h++)
                {
                    nums[i][j][h] = i + 1;
                }
            }
        }

    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */
        int sum = 0;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                for (int h = 0; h < 3; h++)
                {
                    sum += nums[i][j][h];
                }
            }
        }
    }

    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|
     *                 / |3  0  0 |
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__|
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */
    {
        //* Длинный способ
        int nums[3][3][3] ={
            {{1, 0, 0}, {0, 0, 0}, {0, 0, 0}},
            {{2, 0, 0}, {0, 0, 0}, {0, 0, 0}},
            {{3, 0, 0}, {0, 0, 0}, {0, 0, 0}}};

        //* Короткий способ
        int nums2[3][3][3] =
        {
            {1},
            {2},
            {3}
        };
    }

    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     *
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */
    {
        char first[3][6] = { "word1", "word2", "word3" };

        char *second[3] = {"word1", "word2", "word3"};

        /*
        * Двумерный массив
            - размер строки фиксирован; (6) в моем случае
            - так как строка прдеставляет массив символов, ее можно изменять
        * Массив указателей
            - размер строки не фиксорованный
            - строку нельзя изменять так как троковый литерал размещается в памяти, защищенной от изменения
        */
    }

    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел.
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */

    {
        int N, M;
        cout << "Введите длинну массива N:" << "\n";
        cin >> N;
        cout << "Введите длинну массива M" << "\n";
        cin >> M;

        int **nums = new int *[N];

        for (int i = 0; i < N; i++)
        {
            nums[i] = new int[M];
        }

        srand(static_cast<unsigned int>(time(0)));

        // Заполнение массива
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                nums[i][j] = std::rand() % 100;
            }
        }
        // Нахождение суммы элементов
        int sum = 0;
                for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                sum += nums[i][j];
            }
        }
        cout << "Сумма массива равна: " << sum << "\n";
    /**
     * Задание 2.2.
     *
     * В сформированном массиве отсортируйте каждую строку по убыванию
     * значений. Используйте сортировку "выбором".
     */
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M - 1; j++)
            {
                int max = j;
                for (int k = j + 1; k < M; k++)
                {
                    if (nums[i][max] < nums[i][k])
                    {
                        max = k;
                    }
                }
                int temp = nums[i][j];
                nums[i][j] = nums[i][max];
                nums[i][max] = temp;
            }
        }

    
    /**
     * Задание 2.3.
     *
     * Объявите одномерный массив размерностью N.
     *
     * Сформируйте значение i-ого элемента одномерного массива  равным среднему
     * значению элементов i-ой строки двухмерного массива.
     */
        int *avrgInRow = new int[N];
        for (int i = 0; i < N; i++)
        {
            int avrg = 0;
            for (int j = 0; j < M; j++)
            {
                avrg += nums[i][j];
            }
            avrg = avrg / M;
            avrgInRow[i] = avrg;
        }
        
        delete[] avrgInRow;

        for (int i = 0; i < N; i++)
        {
            delete[] nums[i];
        }
        delete[] nums;
    }
    /**
     * Задание 2.4.
     *
     * Убедитесь, что вся выделенная память очищена.
     *
     * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
     * утечек памяти - с ключом `-fsanitize=address`:
     *
     * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
     *
     * Если после выполнении программы выдаются сообщения об утечках, это
     * означает, что где-то не удалена выделенная память.
     */

    /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */
    {
        int N;
        cout << "Введите количесво элементов массива N: " << "\n";
        cin >> N;
        int p;
        int nums[N];
        for (int i = 0; i < N; i++)
        {
            cout << "Введите число массива: " << "\n";
            cin >> p;
            int j = i;
            while (j > 0 && nums[j - 1] > p)
            {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = p;
        }
        cout << "......................" << "\n";
        for (int i = 0; i < N; i++)
        {
            cout << nums[i] << "  ";
        }
        cout << "\n";

        // Cложность алгоритма O(N^2)
    }

        /**
         * Задание 3.2. Простой поиск.
         *
         * Модифицируйте предыдущее задание следующим образом:очередное значение
         * вводится в массив только при условии, что там еще такого нет (то есть
         * дубли игнорируются).
         */
        {
            int N;
            cout << "Введите количесво элементов массива N: " << "\n";
            cin >> N;
            int p;
            int nums[N];
            int currentSize = 0;
            for (int i = 0; i < N; i++)
            {
                cout << "Введите число массива: " << "\n";
                cin >> p;
                bool isExists = false;
                for (int k = 0; k < currentSize; k++)
                {
                    if (nums[k] == p)
                    {
                        isExists = true;
                        break;
                    }
                }
                if (!isExists)
                {
                    int j = currentSize;

                    while (j > 0 && nums[j - 1] > p)
                    {
                        nums[j] = nums[j - 1];
                        j--;
                    }
                    nums[j] = p;
                    currentSize++;
                }
            }
            cout << "......................" << "\n";
            for (int i = 0; i < currentSize; i++)
            {
                cout << nums[i] << "  ";
            }
            cout << "\n";

        }

    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <cstring>.
     */

    {
        /** Определите необходимые значения как константы */

        // STOP_STRING  -  "*"  //признак "прекратить ввод"
        // M  -  80 //максимальный размер одной строки
        // N  -  10 //максимальное количество строк в массиве
#define M 80
#define N 10
#define STOP_STRING "*"
        /**
         * Объявите двухмерный массив с именем cBuffer типа char и размерностью
         * N*M.
         */
        char cBuffer[N][M];
        /**
         * Объявите массив (с именем cPointers) указателей на строки
         * размерностью N.
         */
        char *cPointers[N];
        int nIndex = 0;

        /**
         * Цикл ввода строк:
         * 1. выведите приглашение для ввода;
         * 2. пока не введена строка STOP_STRING или не заполнен весь массив;
         */
        cout << "Начинайте вводить строки: (максимум : " << N << " )." 
        << "\n" << "Для досрочного завершения ввода введите символ \"*\"."
        << "\n";
        {
            /** ввод строки в массив cBuffer: */
            while (nIndex < N)
            {
                cin >> cBuffer[nIndex];
                if (strcmp(cBuffer[nIndex], STOP_STRING) == 0)
                {
                    break;
                }

                cPointers[nIndex] = cBuffer[nIndex];
                nIndex++;
            }

            /** если введена строка - признак окончания, то выйти из цикла */

            /** Присвойте элементу массива cPointers с индексом nIndex */

            /** указатель на строку с номером nIndex в массиве cBuffer */
        }

        /** Выдать диагностику о том, что прием строк завершен.*/
        cout << "Прием строк завершен. Вы ввели " << nIndex << " строк(и)." << "\n";
        
        /**
         * Теперь сортируем строки.
         *
         * Необходимо использовать сортировку строк по методу "всплывающего
         * пузырька" в порядке возрастания.
         *
         * На каждой итерации - промежуточная печать отсортированных строк.
         */
        for (int i = 0; i < nIndex - 1; i++)
        {
            bool flag = false;
            for (int j = 0; j < nIndex - i - 1; j++) // Сортировка
            {
                if(strcmp(cPointers[j], cPointers[j+1]) > 0)
                {
                    char *temp = cPointers[j];
                    cPointers[j] = cPointers[j + 1];
                    cPointers[j + 1] = temp;
                    flag = true;
                }
            }

            if (flag == false)
            {
                cout << "Конец сортироввки." << "\n";
                cout << "\n"
                     << "................................" << "\n";
                cout << "Итог: \n";
                for (int j = 0; j < nIndex; j++)
                {
                    cout << j + 1 << ")" << cPointers[j] << "\n";
                }
                break;
            }

            for (int k = 0; k < nIndex; k++) // Вывод после каждой сортировки
            {
                cout << (k + 1) << ") " << cPointers[k] << "\n";
            }
            cout << "_______________________" << "\n";


        }
    }

/*
    /**
     * Задание 5. Динамические строки.
     *
     * Реализуйте задание №4, используя не встроенные, а динамические массивы
     * (массив?). Так как строки могут быть разной длины, эффективным решением
     * было бы отводить под каждую строку ровно столько байтов, сколько
     * требуется для ее хранения.
     *
     * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
     * длины (которая помещается в память компьютера - читайте: неограниченной
     * длины).
     *
     * При этом необходимые параметры (количество строк) сформируйте с помощью
     * потока ввода.
     */

    {
        int nStringNumber;
        cout << "Введите количество строк (nStringNumber), которые вы хотите ввести: " << "\n";
        cin >> nStringNumber;

        char **cPointers = new char *[nStringNumber];

        char nowC;


        /** Цикл ввода строк: */
        for (int i = 0; i < nStringNumber; i++)
        {
            string temp = "";
            cout << "Введите строку: " << "\n";
            cin >> temp;

            cPointers[i] = new char[temp.length() + 1];
            strcpy(cPointers[i], temp.c_str());
        }

        cout << "\n" "Начало сортировки:" << "\n";
        cout << "__________________" << "\n";
        /**
         * Цикл сортировки строк по методу "всплывающего пузырька" в порядке
         * возрастания кода первого символа.
         */
        for (int i = 0; i < nStringNumber - 1; i++)
        {
            bool flag = false;

            for (int j = 0; j < nStringNumber - i - 1; j++)
            {
                if(strcmp(cPointers[j], cPointers[j+1]) > 0) // Сортировка
                {
                    char *temp = cPointers[j];
                    cPointers[j] = cPointers[j + 1];
                    cPointers[j + 1] = temp;
                    flag = true;
                }
            }

            if (flag == false) // Проверка (была ли сортировка)
            {
                cout << "Конец сортироввки." << "\n";
                cout << "\n"
                    << "................................" << "\n";
                cout << "Итог: \n";
                for (int j = 0; j < nStringNumber; j++)
                {
                    cout << j + 1 << ")" << cPointers[j] << "\n";
                }
                break;
            }

            for (int j = 0; j < nStringNumber; j++) // Вывод после каждой сортировки
            {
                cout << j + 1 << ")" << cPointers[j] << "\n";
            }
            cout << "__________________" << "\n";
        }

        for (int i = 0; i < nStringNumber; i++)
        {
            delete[] cPointers[i];
        }

        delete[] cPointers;
    }

    /** 
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \ 
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */
    {
        string inputStr;
        cout << "Введите строку:" << "\n";
        cin.ignore();
        getline(cin, inputStr);
        unsigned int strCounter = 0;
        unsigned int wordsCounter = 0;
        char **words = new char *[inputStr.length()];

        string word = "";

        for (int i = 0; i < inputStr.length(); i++) // Разбиение строки на слова
        {
            if (inputStr[i] != ' ' && i != inputStr.length() - 1)
            {
                word += inputStr[i];
            }
            else
            {
                if (i == inputStr.length() - 1)
                    word += inputStr[i];
                if (word.length() > MAX_WORD_LENGTH)
                    return 0;
                words[wordsCounter] = new char[word.length() + 1];
                strcpy(words[wordsCounter++], word.c_str());
                word = "";
            }
        }
        cout << "  __________________________________________" << "\n";
        // 12345 12345 12345 12345 12345 12345 12345 12345 123456789 123456789
        string now = "";
        for (int i = 0; i < wordsCounter; i++)
        {
            if (now.length() + strlen(words[i]) < MAX_WORD_LENGTH)
            {
                now += words[i];
                now += ' ';
            }
            else
            {
                string endspace((40 - (now.length() - 1)), ' ');
                cout << " |" << ' ' << now << endspace << '|' << "\n";
                now = words[i];
                now += ' ';
            }
        }
        string endspace((40 - (now.length() - 1)), ' ');
        cout << " |" << ' ' << now << endspace << '|' << "\n";
        cout << "  __________________________________________" << "\n";

    //         cout << R"(     \
    //   \
    //     /\_/\  (
    //    ( ^.^ ) _)
    //      \"/  (
    //    ( | | )
    //   (__d b__)
    //             )"
    //              << "\n";
    std::cout << "     \\ \n";
    std::cout << "      \\ \n";
    std::cout << "        /\\_/\\  (\n";
    std::cout << "       ( ^.^ ) _)\n";
    std::cout << "         \\\"/  (\n";
    std::cout << "       ( | | )\n";
    std::cout << "      (__d b__)\n";

        for (int i = 0; i < wordsCounter; i++)
        {
            delete[] words[i];
        }
        delete[] words;
    }

    /** 
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|     
     *                     / |4  4  4 |     
     *                   |--------| 4 | 
     *                 / |3  3  3 | 4 | 
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|     
     *                     / |3  3  3 |     
     *                   |--------| 3 | 
     *                 / |4  4  4 | 3 | 
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__| 
     *            | 2  2  2 | /
     *            |_________|
     */

    {
        double dArray[4][3][3] = {
        {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
        {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}},
        {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}},
        {{4, 4, 4}, {4, 4, 4}, {4, 4, 4}},
        };
        std::cout << "Массив до перестановки:" << std::endl;
        for (int i = 0; i < 4; i++) 
        {
            std::cout << "Слой " << i + 1 << ":" << std::endl;
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    std::cout << dArray[i][j][k] << " ";
                }
                std::cout << std::endl;
            }
        }

        for (int i = 0; i < 3; i+=2)
        {
            /**
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!!
             */

            double (*one)[3] = dArray[i];
            double(*two)[3] = dArray[i + 1];

            /** переставляем местами элементы i-того и i+1-ого слоев */
            for (int j = 0; j < 3; j++)
            {
                for (int k = 0; k < 3; k++)
                {
                    double temp = one[j][k];
                    one[j][k] = two[j][k];
                    two[j][k] = temp;
                }
            }
        }

        cout << "________________" << "\n" << "Массив после перестановки \n";

        for (int i = 0; i < 4; i++)// Вывод после переставновки
        {
            std::cout << "Слой " << i + 1 << ":" << std::endl;
            for (int j = 0; j < 3; j++)
            {
                for (int k = 0; k < 3; k++)
                {
                    std::cout << dArray[i][j][k] << " ";
                }
                std::cout << std::endl;
            }
        }
    }
    
    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N 
     * операций, где N - длина строки, k - некое фиксированное число.
     */
    
    {
        unsigned short rows;
        unsigned short columns;

        cout << "Введите количество строк: \n";
        cin >> rows;

        cout << "Введите количество столбцов: \n";
        cin >> columns;

        char myArr[rows][columns];

        std::srand(static_cast<unsigned short>(time(0)));

        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                myArr[i][j] = (std::rand() % 2 == 0 ? '*' : '_');
            }
        }

        cout << "Массив до сортировки: \n";
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                cout << myArr[i][j] << " ";
            }
            cout << "\n";
        }

        for (int i = 0; i < rows; i++) // Перебор строк
        {
            unsigned int snowCounter = 0;
            for (int j = 0; j - 1 < columns; j++) // Перебор столбцов; Сортировка строки O(n)
            {
                if (myArr[i][j] == '*')
                {
                    myArr[i][j] = '_';
                    myArr[i][snowCounter++] = '*';
                }
            }
        }

            cout << "Массив после сортировки: \n";
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                cout << myArr[i][j] << " ";
            }
            cout << "\n";
        }
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

{
        unsigned short rows;
        unsigned short columns;

        cout << "Введите количество строк: \n";
        cin >> rows;

        cout << "Введите количество столбцов: \n";
        cin >> columns;

        char myArr[rows][columns];

        std::srand(static_cast<unsigned short>(time(0)));

        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                myArr[i][j] = (std::rand() % 2 == 0 ? '*' : '_');
            }
        }

        cout << "Массив до сортировки: \n";
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                cout << myArr[i][j] << " ";
            }
            cout << "\n";
        }

        for (int i = 0; i < columns; i++) // Перебор столбцов
        {
            unsigned int _counter = 0;
            for (int j = 0; j < rows; j++) // Перебор строк; Сортировка столбца O(n)
            {
                if (myArr[j][i] == '_')
                {
                    myArr[j][i] = '*';
                    myArr[_counter++][i] = '_';
                }
            }
        }

            cout << "Массив после сортировки: \n";
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                cout << myArr[i][j] << " ";
            }
            cout << "\n";
        }
    }


    
    return 0;
}
