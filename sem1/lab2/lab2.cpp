/**
 * Практическое занятие №2. Побитовые операторы. Директивы препроцессора.
 * Указатели.
 */

#include <iostream>
#include <cmath>

#define LENGHT(radius) (2 * M_PI * radius)

using std::cout, std::cin;
int main()
{
    /**
     * Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
     */

    /**
     * Задание 1.1.
     *
     * Задайте значение переменной `y`, например, с помощью потока ввода.
     *
     * 1. С помощью побитовых операторов и операторов сдвига выведите значение
     *    переменной `y` на консоль в двоичном виде.
     * 2. Сделайте то же, но пропустив незначащие нули.
     *
     * Например, если `y == 9`, то должно получиться
     * 1. `0 0 0 0 ... 0 0 1 0 0 1` (количество двоичных цифр зависит от
     *    платформы).
     * 2. `1 0 0 1`.
     *
     * Что выведет ваша программа, если ввести отрицательное число? Объясните
     * этот результат.
     */
    {
        cout << "Task 1.1" << '\n';
        cout << "Введите y:" << '\n';

        int y;
        cin >> y;
        cout << "Ваше число в двоичной СС: " << '\n';
        short size = sizeof(y) * 8;

        //* Первый вывод
        cout << "1)";
        for (int i = (size - 1); i >= 0; i--)
        {
            cout << ((y >> i) & 1);
        }
        cout << '\n';

        // * Второй вывод
        bool flag = false;

        cout << "2)";
        for (int i = (size - 1); i >= 0; i--)
        {
            if ((((y >> i) & 1) != 0) || flag)
            {
                cout << ((y >> i) & 1);
                flag = true;
            }
        }
        if (!flag)
            cout << '0';
        cout << '\n';

        /*
         * При вводе отрицательного числа у нас получаются одниковые результаты в 1 и 2 случае, так как отрицательное
         * число в двоичном коде предствлятется как "инверсия положительного + 1" => у нас число всегда начинается с 1.
         */
    }

    /**
     * Задание 1.2.
     *
     * Дана целая переменная `y`, задайте ее значение, например, с помощью
     * потока ввода.
     *
     * В рамках одного цикла "сдвиньте" все единицы в переменной `y` вправо,
     * обновив тем самым значение этой переменной.
     *
     * Например:
     * было:  0100 1111 0000 0000 0110 1111 0000 0010 -- 1325428482
     * стало: 0000 0000 0000 0000 0000 1111 1111 1111
     *
     * Выведите переменную на экран в двоичном виде до преобразования и после,
     * используя код из задания 1.1.
     */

    {
        cout << "Task 1.2" << '\n';

        int y;
        int newY = 0;

        cout << "Введите y:" << '\n';
        cin >> y;
        unsigned short size = sizeof(y) * 8;

        cout << "y был: ";
        for (int i = (size - 1); i >= 0; i--)
        {
            cout << ((y >> i) & 1);
        }
        cout << '\n';

        unsigned short unitsCount = 0;

        for (int i = 0; i < size; i++) // сдвиг едениц
        {
            if ((y >> i) & 1)
            {
                unitsCount++;
                newY |= 1 << (unitsCount - 1);
            }
        }

        cout << "y стал: ";
        for (int i = (size - 1); i >= 0; i--)
        {
            cout << ((newY >> i) & 1);
        }
        cout << '\n';
    }

    /**
     * Задание 1.3.
     *
     * Дана целая переменная `y`, задайте ее значение.
     *
     * Напишите код, который с помощью побитовых операций:
     *
     * 1. вычислит `y * 2^n`, где целое `n` (0 <= n < 16) задается отдельно;
     * 2. проверит, делится ли `y` на 2, проверит, делится ли `y` на 4;
     * 3. вычислит целую часть логорифма `y` по основанию 2.
     */

    {
        cout << "Task 1.3" << '\n';
        int y, n;
        cout << "Введите y:";
        cin >> y;

        bool success = false;
        while (!success)
        {
            cout << "Ввеидте n в промежутке (0 <= n < 16)" << '\n';
            cin >> n;
            if (n >= 0 && n <= 16)
                success = true;
        }
        cout << "1)" << (y << n) << '\n';

        bool isDevidedBy2 = ((y & 1) == 0);
        cout << "2) y делиться на 2: " << isDevidedBy2 << '\n';

        bool isDevidedBy4 = ((y & 3) == 0);
        cout << "2) y делиться на 4: " << isDevidedBy4 << '\n';

        unsigned short firstUnitNumber = 0;
        unsigned short size = sizeof(y) * 8;
        for (int i = (size - 1); i >= 0; i--)
        {
            if ((y >> i) & 1)
            {
                firstUnitNumber = i;
                break;
            }
        }
        cout << "3) Целая часть log2(y): " << firstUnitNumber << '\n';
    }

    /**
     * Задание 1.4.
     *
     * Какие операции следует применить к заданному ниже операнду sNum для
     * того, чтобы переменная sRes приняла требуемое значение? Каждую побитовую
     * операцию можно использовать только 1 раз.
     *
     * Замечание: значения подобраны таким образом, что в каждом случае
     * достаточно использовать один оператор (и при необходимости маску).
     */

    {
        short sNum = 0x8008; //* 1000 0000 0000 1000
        short sRes;

        /** sRes == 0x7ff7 */ //* 0111 1111 1111 0111
        sRes = ~sNum;

        /** sRes == 0x8ff8 */ //* 1000 1111 1111 1000
        sRes = sNum | 0x8ff8;

        /** sRes == 0x0008 */ //* 0000 0000 0000 1000
        sRes = sNum & 0x0008;

        /** sRes == 0x7f08 */ //* 0111 1111 0000 1000
        sRes = sNum ^ 0xff00;

        /** sRes == 0xf001 */ //* 1111 0000 0000 0001
        sRes = sNum >> 3;

        /** sRes == 0x0010 */ //* 0000 0000 0001 0000
        sRes = sNum << 1;
    }

    /**
     * Задание 2. Директивы препроцессора.
     */

    /**
     * Задание 2.1. Использование "математических" макросов стандартной
     * библиотеки.
     *
     * В заголовочном файле <cmath> (который в свою очередь включает старый
     * файл math.h) определены часто используемые математические константы,
     * например M_PI. Воспользуйтесь этой константой для вычисления длины
     * окружности.
     */

    {
        float radius = 1;
        float circumference = 2 * M_PI * radius;
    }

    /**
     * Задание 2.2. Макросы с параметрами.
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите свою макроподстановку LENGHT которая вычисляет длину
     * окружности.
     */

    {
        /** Протестируйте написанный макрос для следующих ситуаций */

        float l1 = LENGHT(1 + 2); // должно быть 18.8495...
        float l2 = 1 / LENGHT(2); // должно быть 0.07957...
        //* Верно
    }

    /**
     * Задание 2.2.2.
     *
     * Определите макрос MAX(A, B) для вычисления большего значения из двух.
     */
#define MAX(a, b) (a >= b ? a : b)
    {
        /**
         * Используйте макрос следующим образом. Следите за изменением значений
         * переменных k, i, j. Объясните результат.
         *
         * Постарайтесь убрать побочные эффекты.
         *
         * Отметьте случаи, когда избежать побочных эффектов невозможно.
         */

        int i = 10, j = 12, k;
        k = MAX(i, j);     // i = 10, j = 12, k = 12
        k = MAX(j, i) * 2; // i = 10, j = 12, k = 24
        k = MAX(j, i + 3); // i = 10, j = 12, k = 13
        k = MAX(i--, j++); // k = 13 , j = 14 (побочный эффект)
                           //* Избежать побочных эффектов невозможно при передаче данных, которые изменяются в процессе обработки
    }

    /**
     * Задание 2.2.3.
     *
     * Определите макрос EXCHANGE(X, Y)  для перестановки двух объектов типа
     * int в памяти местами.
     *
     * Проверьте для приведенного фрагмента.
     *
     * Подумайте, что будет делать макроподстановка, если переставляемые
     * значения разного типа???
     */
#define EXCHANGE(x, y) ({ int temp = y;  y = x;  x = temp; })
    {
        int x1 = 1, y1 = -1;
        EXCHANGE(x1, y1);

        int x2 = 100, y2 = -100;
        EXCHANGE(x2, y2);
        //* Если значения разного типа, произойдет потеря точности
    }

    /**
     * Задание 2.3. Директивы условной трансляции.
     *
     * Выполняя следующий фрагмент, посмотрите, какое значение принимает
     * переменная iNN.
     *
     * Что нужно сделать для того, чтобы результат был равен 0? 1? 2?
     */

    {
        int iNN;
#if defined NNN && defined MMM
        iNN = 0;
#elif defined MMM
        iNN = 1;
#elif defined NNN
        iNN = 2;

#else
        iNN = -1;
#endif
        //* iNN примет значение -1
        /*
         * Чтобы результат был равен 0 нужно добавить до проверки "#define NNN" и "define MMM".
         * Чтобы результат был равен 1 нужно добавить до проверки только "#define MMM".
         * Чтобы результат был равен 2 нужно добавить до проверки только "#define NNN".
         */
    }

    /**
     * Задание 2.4. Задание директив при сборке.
     *
     * При сборке программы компилятором можно установить необходимые
     * макроподстановки с помощью ключа `-D`. Например, чтобы при сборке
     * была определена директива `A` без значения и директива `B` со значением
     * `1`, надо добавить следующие ключи к команде сборки: `-D A -D B=1`.
     * Таким образом команда сборки будет выглядеть примерно так:
     *
     * `gcc -g -D A -D B=1 lab2.cpp`
     *
     * Уберите из кода определения макросов NNN и MMM из прошлого задания и
     * приведите команды компиляции, которые заставят переменную iNN принять
     * нужное значение.
     * *clang++ lab2.cpp -g -D NNN -D MMM
     *
     * Проверьте их работоспособность.
     */
    {
        int iNN = 0;
#if defined NNN && defined MMM
        iNN = 100;
#endif
        iNN = 20;
    }
    //* Работает
    /**
     * Задание 2.5. Сборки "DEBUG" и "RELEASE". Предопределенные макросы
     * компилятора.
     *
     * При отладке удобно выводить дополнительную информацию, которая может
     * мешать в итоговой (релизной) версии программы.
     *
     * Существует стандартный макрос, который принято устанавливать при
     * релизной сборке - `NDEBUG`.
     *
     * С помощью макроса NDEBUG и предопределенных макросов выведите на консоль
     * для отладочной версии информацию о том, что это отладочная сборка, о
     * дате сборки, о имени файла, имени функции и строки. Для релизной сборки
     * такая информация не должна выводиться.
     *
     * Для защиты работы соберите две версии программы: отладочную и итоговую.
     * Чтобы собрать итоговую версию в другом исполняемом файле, используйте
     * ключ компилятора `-o`, примерно так:
     *
     * `gcc <ваши опции> -o release.out lab2.cpp`
     */

#ifndef NDEBUG
    cout << "Это отладочная сборка" << "\n";
    cout << "Дата сборки: " << __DATE__ << "\n";
    cout << "Имя файла: " << __FILE__ << "\n";
    cout << "Имя функции: " << __FUNCTION__ << "\n";
    cout << "Строка: " << __LINE__ << "\n";
#else
    cout << "Release" << "\n";
#endif
    /**
     * Задание 3.Заголовочные файлы. Директива #include.
     */

    /**
     * Задания 3.1.
     *
     * Создайте и подключите к проекту два заголовочных файла 1.h и 2.h.
     *
     * В каждом заголовочном файле объявите перечисление с одинаковыми именами
     * констант, но сопоставьте именованным константам разные значения,
     * например:
     *
     * - 1.h - enum MyEnum{My1, My2, My3};
     * - 2.h - enum MyEnum{My1=5, My2, My3};
     *
     * С помощью директив условной трансляции в DEBUG-версии пользуйтесь
     * значениями констант из 1.h, а в RELEASE-версии значениями констант из
     * 2.h.
     *
     * Замечание: заголовочные файлы принято подключать в верхней части файла,
     * до любых функций (хотя правила компиляции не запрещают подключить их
     * тут).
     */

#ifndef NDEBUG
#include "1.h"
    MyEnum value1 = My1;
    MyEnum value2 = My2;
    MyEnum value3 = My3;
#else
#include "2.h"
    MyEnum value1 = My1;
    MyEnum value2 = My2;
    MyEnum value3 = My3;
#endif
    /**
     * Задание 4. Указатели.
     */

    /**
     * Задание 4.1.
     *
     * Объявите объекты разных типов и проинициализируйте их.
     *
     * Объявите указатели соответствующих типов и проинициализируйте их
     * адресами заданных объектов.
     *
     * Выполняя задание, с помощью отладчика посмотрите, какие значения будут
     * присвоены переменным-указателям и на что эти указатели "указывают".
     */

    {
        int iInt = 10;
        double iDouble = 10.5;

        int *pInt = &iInt;          //* 0x16fdff098
        double *pDouble = &iDouble; //* 0x16fdff090
        std::cout << "first: " << pInt << " " << "second: " << pDouble << "\n";
        //* Указатели "Указывают" на адресс переменной. В данном случае pInt указывает на адресс Int, pDouble указывает на адресс iDouble.
    }

    /**
     * Задание 4.2.
     *
     * Объявите указатель на тип char и проинициализируйте его адресом
     * строкового литерала. Присвойте переменной типа char значение любого
     * элемента строки.
     *
     * Проверьте - возможно ли присвоить какое-либо значение по адресу,
     * задаваемому указателем?
     */

    {
        char *pChar = "Some text";
        char iChar = pChar[3];
        //* pChar[1] = 'O'; вызовет ошибку Exception has occurred.EXC_BAD_ACCESS (code=2, address=0x100003ebf) так как строковые литералы невозможно изменить
    }

    /**
     * Задание 5. Арифметика указателей. Операция разыменования указателя.
     *
     * Выполните следующий код по строчкам в отладчике, проследите за
     * изменением значений указателей и значений объектов, на которые они
     * указывают.
     *
     * Интерпретируте наблюдаемые результаты.
     */
    {
        int nAr[3] = {1, 3}; //* [1,3,0]
        int *pn = &nAr[0];   //* 1 | 0x000000016fdff238
        (*pn)++;             //* 2 (К значению на который указывает указатель прибавляется 1)
        pn++;                //* 3 (К указателю прибавляется 1, теперь он указывает на следующий элемент массива = 3)

        char cAr[] = {'A', 'B', 'C', 'D'};
        char *pc = &cAr[0]; //* A | 0x000000016fdff144
        (*pc) = (*pc) + 5;  //* F (Первый элемент массива меняется на F. Здесь происходит замена значения, на которое указывает указатель)
        pc = pc + 3;        //* Теперь указатель указвает на 4 элемент массива с индексом 3 (D)

        double dAr[3] = {1.0, 2.0};
        double *pd1 = &dAr[0]; //* 1 | 0x000000016fdff220
        double *pd2 = pd1;     //* 1 (Указатель pd2 теперь указывает на то же значение, что и pd1)
        (*pd2) += 2;           //* К значению, на которое указывает указатель pd2 прибавляется 2. => первый элемнт массива становится равным 3
        pd2 += 2;              //* Указатель смещается на 2 элемента, теперь он указывает на 3 элемент массива с индексом 2 (0).

        /** Объясните результат выполнения операции вычитания двух указателей */
        pd1 = &dAr[0];
        pd2 = &dAr[1];
        int nNumber = pd2 - pd1; //* nNumber = 1. Разность указателей в данном случае будет показывать каково растояние между эл-тами массива(разность индексов).

        /**
         * Сравните указатели pd2 и pd1 и с помощью cout выведите результаты
         * сравнения.
         */
        if (pd1 < pd2)
            cout << "pd1 < pd2" << "\n";
        else if (pd1 > pd2)
            cout << "pd1 > pd2" << "\n";
        else
            cout << "pd1 = pd2" << "\n";
    }
    /**
     * Задание 6. Явное преобразование указателя.
     *
     * Иногда возникает необходимость одни и те же данные интерпретировать
     * по-разному, например, целое можно представить как совокупность четырех
     * байтов и работать с каждым байтом по отдельности. Для этого нужно иметь
     * возможность "указывать" как на целое, так и на байт.
     *
     * Следовательно, возникает необходимость явного преобразования указателя.
     *
     * Подсказка: для правильной интерпретации этого задания воспользуйтесь
     * возможностями отладчика представлять данные в интересующем Вас виде (в
     * данном случае - в шестнадцатеричном) - для этого можно использовать
     * команду print (p) с указанием шестнадцетиричного формата: `p/x`.
     */

    {
        unsigned int nObject = 0x55667788;
        unsigned int *pnObject = &nObject;
        unsigned char *pucObject;
        char cc;

        /**
         * Раскомментировав следующую строчку кода, обратите внимание на
         * сообщение компилятора - он не считает преобразование "легальным"
         * (безопасным)
         */
        // pucObject = static_cast<unsigned char*>(pnObject);
        //* преобразование указателя на unsigned int в указатель на unsigned char небезопасно

        /**
         * А такое преобразование - целиком на совести программиста. Его можно
         * применять, только четко представляя себе результат преобразования.
         */
        pucObject = reinterpret_cast<unsigned char *>(pnObject);

        /** Проследите за значениями переменной `cc`. Объясните результаты. */
        cc = pucObject[0]; //* 0x88
        cc = pucObject[1]; //* 0x77
        cc = pucObject[2]; //* 0x66
        cc = pucObject[3]; //* 0x55
        /*
         * После преобразования pnObject, который указывает на unsigned int с размером 4 байта, в pucObject, который
         * указывает на unsigned char с размером 1 байт, получили указатель pucObject, которой указывает на каждый из
         * 4 байтов по отдельности. Так pucObject[0] указывает на 1 байт, pucObject[1] на 2 и т.д. Поочередность байтов
         * зависит от типа системы (big-endian/little-endian).
         */

        /**
         * Выполните следующие строки, наблюдая за значениями следующих
         * выражений: `cc`, `p` и `*p`.
         *
         * Зафиксируйте и интерпретируйте результаты.
         */
        cc = *(pucObject++); //* cc = 0x88, но теперь pucObject указывает на 2 байт (0x77).
        cc = (*pucObject)++; //* cc = 0x77, но теперь второй байт, на который указывает pucObject = 0x78.

        cc = ++*(pucObject); //* cc = 0x79, теперь второй байт на который указывает pucObject = 0x79.
        cc = *(++pucObject); //* cc = 0x66, теперь pucObject указывает на 3 байт (0x66)
    }

    /**
     * Задание 7. Void-указатель.
     */

    /**
     * Задание 7.1.
     *
     * Выполняя задание, посмотрите - какие значения присваиваются
     * void-указателю.
     *
     * Обратите внимание: средствами отладчика вы не можете посмотреть
     * значения, на которые "указывает" void-указатель.
     */
    {
        void *pVoid;
        int nObject3 = 5;
        char cObject3 = 'A';
        int *pInt = &nObject3;
        pVoid = &nObject3; // 0x000000016fdff00c
        pVoid = &cObject3; // 0x000000016fdff00b
        pVoid = pInt;      // 0x000000016fdff00c

        /**
         * Прежде, чем раскомментировать следующую строчку, вспомните: что
         * нужно сделать, чтобы выражение стало корректным?
         */
        pInt = static_cast<int *>(pVoid);
    }

    /**
     * Что нужно сделать для того, чтобы следующее закомментированное выражение
     * стало корректным?
     *
     * В закоментированной строке необходимо объявить void-указатель.
     */
    {
        const int n = 1;
        const void *pn = &n;
    }

    /**
     * Задание 7.2.
     *
     * При выполнении следующего фрагмента посмотрите, какие неприятности могут
     * Вас ожидать при явном приведении типа void-указателя, который в момент
     * времени (1) указывает на double, к типу указателя на int (2).
     */

    {
        double dObject3 = 33.33;
        void *pVoid = &dObject3; //(1)

        int nTmp = *(static_cast<int *>(pVoid)); //(2)
        //* nTmp = 1889785610 так как double имеет размер 8 байт, а int 4 байт
    }

    /**
     * Задание 8. Модификатор const.
     */

    /**
     * Задание 8.1.
     *
     * В каждом из заданий объявите указатель требуемого вида.
     *
     * Посредством каждого указателя попробуйте:
     *
     * - получить значение по адресу;
     * - записать новое значение по адресу;
     * - модифицировать указатель.
     */

    /**
     * Задание 8.1.1. Указатель является константой.
     */

    {
        int n = 10;
        int *const pn = &n;
        cout << *pn << "\n"; //* получение значения
        *pn = 20;            //* изменение значения по адресу

        int b = 8;
        // pn = &b;
        //! невозиожно так как указатель const
    }

    /**
     * Задание 8.1.2. Указываемое значение является константой.
     */

    {
        const int n = 10;
        int const *pn = &n;
        cout << *pn << "\n"; //* получение значения

        /* *pn = 20; */
        //! изменение значения по адресу невозможно, так как переменная const

        int b = 8;
        pn = &b; // изменение указателя
    }

    /**
     * Задание 8.1.3. И указатель, и указываемое значение являются константами.
     */

    {
        const int n = 10;
        const int *const pn = &n;
        cout << *pn << "\n"; //* получение значения
        //! изменить значения указателя или сам указатель не получится
    }

    /**
     * Задание 8.2. Указатель на переменную, объявленную с ключевым словом
     * const.
     *
     * Объявите указатель и проинициализируйте его выражением - `&nN`.
     */

    {
        const int nN = 1;
        const int *pn = &nN;
    }

    /**
     * Задание 9. Указатели на указатели.
     */

    {
        int n = 1;

        /**
         * Объявите указатель pn и проинициализируйте его так, чтобы он
         * "указывал" на n.
         */
        int *pn = &n;
        /**
         * Объявите указатель ppn и проинициализируйте его так, чтобы он
         * "указывал" на pn.
         */
        int **ppn = &pn;
        /**
         * Объявите указатель pppn и проинициализируйте его так, чтобы он
         * "указывал" на ppn.
         */
        int ***pppn = &ppn;
        /**
         * С помощью указателей pn, ppn и pppn получите значение объекта n и
         * присвойте его m.
         */

        int m = *pn;
        m = **ppn;
        m = ***pppn;
    }
    return 0;
}
