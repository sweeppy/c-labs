/**
 * Практическое занятие №1. Базовые типы данных, операторы языка, простой
 * ввод-вывод.
 *
 * В результате выполнения данной работы слушатель получает много мелких, но
 * необходимых для дальнейшей работы навыков, поэтому задание построено как
 * последовательность закомментированных блоков, которые требуется
 * последовательно раскомментировать, отвечая при этом на поставленные вопросы.
 *
 * Необходимое программное обеспечение:
 *
 * - Unix-совместимая командная строка (для Windows необходимо установить WSL);
 * - компилятор g++, отладчик gdb (для установки в командной строке: 
 *   `apt update; apt install gcc g++ gdb`)
 * - любимый текстовый редактор.
 *
 * Примерная последовательность действий при отладке проекта:
 * 1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст
 *    программы;
 * 2. скомпилируйте программу (в командной строке: `g++ -g lab1.cpp`);
 * 3. запустите отладчик (в командной строке `gdb ./a.out`);
 * 4. в отладчике установите точку останова на нужной строке (например, 
 *    `break 55` для 55 строки или `b 55` - так короче) и начните выполнение 
 *    программы (`run` или `r`).
 * 5. выведите значение интересующей переменной (`print cByte` или `p cByte`)
 *    или добавьте переменную для постоянного отслеживания (`watch cByte`).
 * 6. Переходите к следующей точке останова (`c`) или к следующей строке (`n`).
 */

#include  <iostream>

int nTwin = 1;
namespace TwinSpace { int nTwin = 2; }
int main()
{

    /**
     * Задание 1. Работа с отладчиком. Базовые типы данных. Литералы.
     *
     * Выполняя программу по шагам, следите за значениями переменных и
     * интерпретируйте результат (помните, что количество байт, отводимых под
     * int, системо-зависимо).
     *
     * Обратите внимание на разную интерпретацию отладчиком signed и unsigned
     * целых типов данных, а также на внутреннее представление отрицательных
     * целых чисел.
     */
    
    char cByte = 'A';
    cByte = 0x42;
    cByte = 66;
    cByte = -1;

    unsigned char ucByte = 0x41; 
    ucByte = 'B';
    ucByte = -1;
    ucByte = -100;
    ucByte = -20;
    ucByte = 0;

    // TODO: попробовать с другими отрицательными числами, правда ли будет максимальное?
    // * нет, будет не максимальное, будет число равное 2^8 + (отрицательное число % 256)
    int iInt = 0xffffffff; // * -1

    unsigned int uiInt = 0xffffffff; // TODO: сколько байт в unsigned int?
    // * 4 байта. За счет того, что знаковая часть убралась, число будет вмещать большие числа

    float fFloat = 1.f;  
    double dDouble = 1.; 

    /**
     * Выполните фрагмент, приведенный далее. В комментариях отразите, что
     * реально заносится в переменную. Объясните разницу между этим значением и
     * инициализатором.
     */

    double d = 0.1234567890123456789123456789; //* 0.12345678901234568
    float  f = 0.1234567890123456789123456789; //* 0.123456791

    d = 0.0000000000000000000000000000000000000000000000000001231232112312; // TODO: точно ли это 0?
    //* 1.2312321123119999E-52

    d = 1.; // 1
    d = 0.999999999999999999999999999999999; //* 1

    /**
     * В комментариях напишите результат, возвращаемый оператором sizeof для
     * переменной типа wchar_t (ее размер)
     */

    wchar_t cw = L'Ф';
    size_t n = sizeof(cw); //* 4 // TODO: сомнительно, перепроверьте

    /**
     * Задание 2a. Неявное приведение типов данных. 
     *
     * Объясните разницу результата при выполнении (1) и (2): Покажите явно
     * (напишите в коде) преобразования, которые неявно выполняет компилятор
     */

    iInt = 1;
    double dDouble1 = iInt / 3; // * dDouble1 = 0 (целочисленное деление)
    double dDouble2 = iInt / 3.; 
    /*
        * dDouble2 = 0.333... 
        * (деление int на double невозможно, поэтому компилятор неявно
        * приводит int к double и выполняет деление double на double)
    */
    /* 
        TODO Покажите явно(напишите в коде) преобразования, 
        TODO которые неявно выполняет компилятор
    */
    {
        double dDouble1 = static_cast<double>(iInt / 3);
        double dDouble2 = static_cast<double>(iInt) / 3.;
    }

    /**
     * Ассоциативность операторов.
     *
     * Синтаксис языка C допускает "цепочечное" присваивание (как в строках (1)
     * и (2)). Посмотрев результаты выполнения строк (1) и (2) (значения
     * переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок
     * выполнения присваиваний при цепочечной записи и объясните результат.
     *
     * Расставьте скобки, явно определяющие порядок выполнения, как это сделал
     * бы компилятор. Объясните (в комментариях) предупреждения (warnings)
     * компилятора.
     */

    short sShort;
    dDouble = (fFloat = (iInt = (sShort = (cByte = 3.3 / 3)))); // (1)
    //* dDouble = 1
    
    cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));; // (2)
    //* cByte = 1
    //! warnings:
    /*
        lab1.cpp:124:22: warning: implicit conversion increases floating-point precision: 'float' to 'double' [-Wdouble-promotion]
            dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3; // (1)
                    ~ ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        lab1.cpp:124:52: warning: implicit conversion turns floating-point number into integer: 'double' to 'char' [-Wfloat-conversion]
            dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3; // (1)
                                                    ~ ~~~~^~~
        lab1.cpp:127:21: warning: implicit conversion loses integer precision: 'short' to 'char' [-Wimplicit-int-conversion]
            cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));; // (2)
                ~  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        lab1.cpp:127:29: warning: implicit conversion loses integer precision: 'int' to 'short' [-Wimplicit-int-conversion]
            cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));; // (2)
                            ~  ~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        lab1.cpp:127:39: warning: implicit conversion turns floating-point number into integer: 'float' to 'int' [-Wfloat-conversion]
            cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));; // (2)
                                    ~  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~
        lab1.cpp:127:50: warning: implicit conversion loses floating-point precision: 'double' to 'float' [-Wimplicit-float-conversion]
            cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));; // (2)
    */
    //* Ошибки вызваны потерей точности при неявном присваивании

    /**
     * Ниже Вам дан пример "небрежного" использования неявного приведения
     * типов, что может привести к нежелательным результатам - объясните (в
     * комментариях), к каким?
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор.
     */

    iInt = 257;
    cByte = iInt;
    // ! Результат cByte станер равным 1
    /*
    * Объяснение:
    * Под переменную int выделено 4 байта памяти, под char 1 байт.
    * Поэтому при переводе чисда 257 = 100000001 один бит обрезается,
    * так как char вмещает только 8 бит получается: 1|00000001 = 1 = cByte
    */
    // todo Напишите явно преобразования, которые неявно выполняет компилятор.
    {
        cByte = static_cast<char>(iInt);
    }

    unsigned char cN1 = 255, cN2 = 2, cSum;
    cSum = cN1 + cN2;
    // ! Результат cSum станер равным 1
    /*
    * Объяснение:
    * Под переменную char выделен 1 байт памяти.
    * Поэтому при переводе чисда 255+2=257 = 100000001 один бит обрезается,
    * так как char вмещает только 8 бит получается: 1|00000001 = 1 = cSum
    */
    // todo Напишите явно преобразования, которые неявно выполняет компилятор.
    {
        cSum = static_cast<unsigned char>(cN1 + cN2);
    }
    /**
     * Сравните предыдущую строчку с приведенной ниже. 
     *
     * Объясните (в комментариях), почему в следующей строке не происходит
     * выход за разрядную сетку
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор
     */

    int iSum = cN1 + cN2;
    /*
    * Объяснение:
    * Под переменную int выделено 4 байта памяти.
    * Поэтому переполнения не происходит и результат считается верно:
    * 255 + 2 = 257
    */
    // todo Напишите явно преобразования, которые неявно выполняет компилятор.
    iSum = static_cast<int>(cN1) + static_cast<int>(cN2);

    /**
     * Напишите, почему при сложении одинаковых значений (одинаковых в двоичной
     * системе) в строках (1) и (2) получаются разные результаты.
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор и
     * объясните, что при этом происходит.
     */

    char c1 = 0xff, c2 = 2;
    unsigned char uc1 = 0xff, uc2 = 2;
    int iSum1 = c1 + c2; //(1)
    int iSum2 = uc1 + uc2; //(2)
    /*
     * Объяснение:
     * Различные значения получаются из-за разного типа данных
     * (char/unsigned char). Так как char вмещает значения от -128 до 127, а
     * unsigned char от 0 до 255, то при инициализации c1 и uc1 получаются
     * разные числа. с1 = 11111111 = (-256+128+64+32+16+8+4+2+1) = -1;
     * uc1 = 11111111 = 255.
     * iSum1 = -1 + 2 = 1.
     * iSum2 = 255 + 2 = 257.
     */
    //todo Напишите явно преобразования, которые неявно выполняет компилятор.
    {
        iSum1 = static_cast<int>(c1) + static_cast<int>(c2);
        iSum2 = static_cast<int>(uc1) + static_cast<int>(uc2);
    }
    /**
     * Задание 2b. Явное приведение типов данных.
     *
     * Проинтерпретируйте результат (значения переменной dDouble) в строке (3).
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор.
     */

    int nTmp = 100, nn = 3;
    dDouble = 3.3 + nTmp / nn; // (3)
    //* Результат dDouble = 36.299999999999997
    //todo Напишите явно преобразования, которые неявно выполняет компилятор.
    dDouble = 3.3 + static_cast<double>(nTmp / n);
    /**
     * todo Получите результат без потери точности с помощью оператора явного
     * todo приведения типа.
     */
    double dDouble3 = 3.3 + static_cast<double>(nTmp) / nn;
    /**
     * Задание 3. Область действия, область видимости и время существования
     * переменных.
     *
     * В этом фрагменте фигурируют четыре переменных с одним и тем же именем
     * nTwin - одна глобальная, вторая определена в своем пространстве имен,
     * (определены выше в начале модуля) третья - локальная внутри функции
     * main(), четвертая - вложенная локальная внутри блока. 
     *
     * В данном задании требуется в выделенных местах фрагмента определить, к
     * какой из четырех переменных идет обращение, а также факт существования и
     * видимости для всех четырех, заполнив приведенные в задании таблицы.
     *
     * Для выведения информации в отладчике можно воспользоваться командой 
     * `info locals`, которая выведет локальные переменные в функции main(),
     * и командой `watch nTwin` или `wacth ::nTwin` для отслеживания значений
     * переменных.
     */

    nTwin = 100; // fitst
    TwinSpace::nTwin = 300; // second
    nTwin++; // first

    int nTwin; // third
    nTwin = 200; // third
    ::nTwin++; // first
    {
        //int nTwin; // fourth
        nTwin = -1; // fourth // TODO: какое правило по разрешению имен, правда ли тут глобальная?
        // * будет использоваться третья переменная (Если мы создадим глобальную переменную и с таким же именем
        // * локальную, то получится, что там где была создана локальная переменная будет использоваться именно
        // * локальная переменная, а не глобальная)
        ::nTwin++; // first
        TwinSpace::nTwin++; //second
    }

    nTwin--; //third


    /**
     * Задание 4. Спецификатор класса памяти - static.
     *
     * 1. Для каждой итерации цикла напишите значения пременных nLocal# и
     *    nStatic#.
     * 2. Напишите, когда выполняется инициализация обеих переменных.
     * 3. Поясните (в комментарии) разницу между способом инициализации
     *    переменных nStatic1 и nStatic2 и поясните побочный эффект, влияющий 
     *    на переменную nLocal2.
     */

    for (int i = 0; i < 3; i++)
    {
        static int nStatic1 = 100;
        int nLocal1 = 100;
        int nLocal2 = 200;
        static int nStatic2 = nLocal2++ * 2;
        nStatic1++;
        nStatic2++;
        nLocal1++;
    }
    /*
    todo 1. Для каждой итерации цикла напишите значения пременных
    todo nLocal# и nStatic#.
    * 1:
    * nStatic1 = 101
    * nStatic2 = 401
    * nLocal1 = 101
    * nLocal2 = 200
    *
    * 2:
    * nStatic1 = 102
    * nStatic2 = 402
    * nLocal1 = 101
    * nLocal2 = 200
    * 3:
    * nStatic1 = 103
    * nStatic2 = 403
    * nLocal1 = 101
    * nLocal2 = 200
    todo 2. Напишите, когда выполняется инициализация обеих переменных.
    * static при первом входе в цикл.
    * local при каждом входе в цикл.
    todo 3. Поясните (в комментарии) разницу между способом инициализации
    todo переменных nStatic1 и nStatic2 и поясните побочный эффект, влияющий 
    todo на переменную nLocal2.
    * Из-за того что static инициализируются только 1 раз при первом
    * обращении, а переменные local при каждом создании, возникает
    * побочный эффект - static меняют свое значение при каждой итерации,
    * а local нет.
    */

    /**
     * Напишите:
     * 1. как изменилось поведение пременной nStatic1?
     * 2. как эта переменная _инициализирована_?
     */

    for (int i = 0; i < 3; i++)
    {
        static int nStatic1; // TODO: каким значением инициализирована nStatic1?
        // * в первой строчке статическая переменная инициализрована значением по умолчанию - (0)
        nStatic1 = 100;
        int nLocal1 = 100;
        nStatic1++;
        nLocal1++;
    }
    /*
    todo 1. как изменилось поведение пременной nStatic1?
    * Так как тут в цикле переменная nStatic1 хоть и является static,
    * но она сбрасывается до 100 при каждой новой итерации. Поэтому
    * можно сказать, что в этом случае она ведет себя как переменная nLocal1.
    todo 2. как эта переменная _инициализирована_?
    * Она инициализирована как static, однако сбрасывается до 100 при
    * каждой новой итерации. При объявлении у нас не задано конкретное число, поэтому там хранится значение по умолчанию - 0
    */

    /**
     * Задание 5. Перечисления - enum.
     *
     * Обратите внимание на явную и неявную инициализацию констант. 
     *
     * Выполняя задание по шагам, следите за значениями, которые принимает
     * переменная myColors.
     */

    enum eColors
    {
        BLACK, // 0
        BLUE, // 1
        GREEN, // 2
        RED=5, // 5
        YELLOW, // 6
        WHITE=RED+4 // 9
    };
    
    eColors myColors; //объявление переменной типа eColors 
    myColors = BLACK; // 0
    myColors = BLUE; // 1
    myColors = GREEN; // 2
    myColors = RED; // 5
    myColors = YELLOW; // 6
    myColors = WHITE; // 9

    int nnn = BLACK; //любой целочисленной переменной можно присвоить
                     //значение из списка инициализирующих значений
    // * nnn = 0
    //Именованные константы можно использовать в выражениях:
    nnn = BLUE | YELLOW; //* побитовое или
    // * nnn = 7
    /**
     * Раскомментируйте следующую строку и обратите внимание на ошибку при
     * компиляции.
     *
     * Модифицируйте выражение таким образом, чтобы компилятор не выдывал
     * ошибки.
     */

    myColors = static_cast<eColors>(1);

    /**
     * Выполните следующее присваивание НЕ меняя перечисление и тип переменной
     * myColors.
     */

    myColors = static_cast<eColors>(123);


    /**
     * Задание 6.1 Логический тип bool.
     *
     * Выполняя задание по шагам, следите за значениями переменной b и
     * интерпретируйте результат. 
     *
     * Напишите эти значения в комментариях.
     */

    int nNumber = 1;
    bool b = (nNumber != 0); // true
    b = (nNumber == 0); // false
    b = (nNumber > 0); // true
    b = (nNumber > 1); // false
    b = 5; // true

    /**
     * Вы всегда можете преобразовать логическое значение к целому явно или
     * компилятор может это сделать самостоятельно (неявно).
     *
     * Обратите внимание: как интерпретирует значения логических переменных
     * компилятор?
     */

    int tmp =  b + 1; //* 2 (true = 1, false = 0)

    /**
     * Задание 6.2.
     *
     * В Григорианском календаре (которым мы все пользуемся) високосный год
     * определяется по следующему алгоритму: високосным является каждый
     * четвертый год, но каждый сотый високосным не является, при этом каждый
     * 400-й год все таки високосный. Т.е. 1823 - не високосный, 1824 -
     * високосный, 1900 - не високосный, 2000 - високосный.
     *
     * Напишите фрагмент кода, такой что логическая переменная isLeapYear
     * принимает значение true, если год, заданный переменной year -
     * високосный. Проверьте значение в отладчике.
     *
     * Указание: в этом задании нельзя использовать операторы if-else, switch и
     * тернарный оператор; необходимо написать логическое выражение в одну
     * строку.
     */

    {
        std::cout << "Task 6.2:" << std::endl;
        int year = 1823;
        year = 1824;
        year = 1900;
        year = 2000;

        bool isLeapYear = ((year % 4 == 0 &&
        (year % 100 != 0 || year % 400 == 0)));
        std::cout << "isLeapYear:" << isLeapYear << std::endl;
        std::cout << "End Task 6.2" << std::endl;
    }

    /**
     * Задание 7. Модификатор const и переменные.
     *
     * Раскомментируйте следующие две строчки и объясните (в комментариях)
     * ошибки при компиляции.
     */

    {
        //  const int nN; //
        //  nN = 1; // !ERROR
        /*
        * const неизменяемая переменная,
        * а тут мы пытаемся объявленной переменной типа const
        * присвоить значение 1
        */
    }
    /**
     * Задание 8. Потоки ввода и вывода C++.
     *
     * Напишите фрагмент кода, который бы с помощью объектов потока std::cin и
     * std::cout делал бы следующее:
     *
     * 1. Выводил бы на экран номер задания.
     * 2. Считывал целое число.
     * 3. Считывал символ.
     * 4. Выводил пользователю введенный им символ.
     * 5. Выводил пользователю введенное им целое число.
     *
     * При этом добавьте в места, где от пользователя ожидается ввод,
     * соответствующие приглашения ко вводу (например, `Введите целое число: `). 
     */

    {
        int inputInt;
        char inputChar;
        std::cout << "Task 6.2:" << std::endl;
        
        std::cout << "Введите целлое число:" << std::endl;
        std::cin >> inputInt;
        std::cout << "Введите символ" << std::endl;
        std::cin >> inputChar;
        std::cout << "Ваш символ и число " << inputInt << " " << inputChar << std::endl;
    }

    /**
     * Задание 9. Логические условные операторы и операторы отношения.
     */

    /**
     * Задание 9.1. 
     *
     * Напишите фрагмент кода, который переводит код символа, хранящийся в
     * переменной ch в противоположный регистр.
     *
     * Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
     * или нажал другую клавишу, которой символ не соответствует.
     *
     * Подсказка: работаем только с символами английского алфавита, для
     * которого в таблице кодов ASCII код каждой буквы нижнего регистра на 0x20
     * больше кода соответствующей буквы верхнего регистра.
     */

    {
        char ch;
        std::cout << "Task 9.1" << std::endl;

        bool success = false;
        while (!success)
        {
            std::cout << "Введите английский символ:" << std::endl;
            std::cin >> ch;
            if (ch >= 'a' && ch <= 'z')
            {
                success = true;
                ch -= 0x20;
            }
            else if (ch >= 'A' && ch <= 'Z')
            {
                success = true;
                ch += 0x20;
            }
            else
            {
                std::cout << "Error! Символ должен быть из английского алфавита"
                          << std::endl;
            }
        }
        std::cout << "Ваш символ в противоположнои регистре: "
                  << ch << std::endl;
    }

    /**
     * Задание 9.2. 
     *
     * Напишите фрагмент кода, который реализует с помощью if (if/else)
     * следующую логику: если x меньше или равен 0, y=0, если x больше 0 но
     * меньше 1, то y=x, если x больше или равен 1, то y=1.
     *
     * Подумайте: какого типа должны или могут быть x и y?
     */
    {
        double x = 0;
        double y;
        std::cout << "Task 9.2" << std::endl;

        if (x <= 0)
            y = 0;
        else if(0 < x && x < 1) // TODO: уверены, что это работает?
            y = x;
        else if(x >= 1)
            y = 1;
        std::cout << "y: " << y << std::endl;
        std::cout << "x: " << x << std::endl;
    }


    /**
     * Задание 9.3 
     *
     * Напишите фрагмент кода, который реализует с помощью switch следующую
     * логику: в переменной cInput типа char дано значение символа, введенного
     * любым способом.
     *
     * Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
     * переменной у значение переменной x.
     *
     * Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
     * переменной у значение (x * 2).
     *
     * Если любой другой симол, то вывести сообщение об ошибке.
     */

    {
        int x = 1;
        int y = 2;
        char ch;
        std::cout << "Введите символ y/n" << std::endl;
        std::cin >> ch;
        switch (ch)
        {
        case ('y'):
            y = x;
            std::cout << "y: " << y << std::endl;
            std::cout << "x: " << x << std::endl;
            break;
        case ('Y'):
            y = x;
            std::cout << "y: " << y << std::endl;
            std::cout << "x: " << x << std::endl;
            break;
        case ('n'):
            y = x * 2;
            std::cout << "y: " << y << std::endl;
            std::cout << "x: " << x << std::endl;
            break;
        case ('N'):
            y = x * 2;
            std::cout << "y: " << y << std::endl;
            std::cout << "x: " << x << std::endl;
            break;
        default:
            std::cout << "Error!" << std::endl;
            break;
        }
    }

    /**
     * Задание 10. Циклы.
     */

    /**
     * Задание 10.1.
     *
     * Напишите фрагмент кода, который реализует с помощью for следующую
     * логику: найти сумму заданного диапазона целых чисел.
     *
     * Введите границы с помощью потока ввода или с помощью средств отладки. 
     *
     * Предусмотрите защиту от ввода нижней границы больше, чем верхней.
     */

    {
        std::cout << "Task 10.1" << std::endl;
        /** сформироыать границы диапазона */
        int left;
        int right;

        int result = 0;

        bool success = false;

        std::cout << "Введите нижнюю границу:" << std::endl;
        // TODO: переосмыслить эту проверку
        std::cin >> left;
        
        while (!success)
        {
            std::cout << "Введите верхнюю границу" << std::endl;
            std::cin >> right;
            if (left > right)
            {
                std::cout << "Error! Верхняя граница должна быть больше правой" << std::endl;
            }
            else success = true;
        }
        
        for (int i = left; i <= right; i++)
        {
            result += i;
        }

        std::cout << "Сумма чисел из вашего диапазона: " << result << std::endl;

        /** проверить корректность значений */
        
        /** вычислить сумму */

        /** проверить в отладчике значение */
    }

    /**
     * Задание 10.2. 
     *
     * Напишите фрагмент кода, который реализует с помощью do-while следующую
     * логику: на каждой итерации цикла ввести с консоли целое значение и
     * покинуть цикл, если значение удовлетворяет условию: значение больше или
     * равно 10 и четное.
     */

    {
        std::cout << "Task 10.2" << std::endl;
        int i;
        do
        {
            std::cout << "Введите число: " << std::endl;
            std::cin >> i;
        } while (!(i >= 10 && i % 2 == 0));
        
    }

    /**
     * Задание 10.3. 
     *
     * Напишите фрагмент кода, который реализует с помощью while следующую логику: 
     *
     * 1. исходно int x = 0; 
     * 2. на каждой итерации x = x + 1, sum = sum + 1 / x;
     * 3. необходимо найти значение x, при котором sum > 1.7.
     */

    {
        std::cout << "Task 10.3" << std::endl;

        // TODO: проверить, работает ли это
        int x = 0;
        double sum = 0;
        while(sum <= 1.7)
        {
            x++;
            sum = sum + 1.0 / x;
        }
        std::cout << "x:" << x << std::endl;
    }

    /**
     * Задание 10.4.
     *
     * Раскомментируйте следующий блок кода, который считает сумму 10
     * последовательных натуральных чисел, начиная со 120. 
     *
     * Объясните логические ошибки в нем и исправьте их.
     */

    {
        int start = 120, sum = 0;
        for (int n = start; n < start + 10; ++n) 
        {
            sum += n;
        }
        /*
        ! char <= 127 => произойдет переполнение. Значит меняю char на int
        */
    }

    return 0; /** код завершения приложения */
}

