/**
 * Практическое занятие №5. "Старые" потоковые функции стандартной библиотеки.
 * Указатели на функции. Структуры.
 */

#include <iostream>
// #include <cstdio>

#include "other.h"
#include "book.h"
#include "matrix.h"

#include <cmath>

Book globalBook;
using std::cout;
int main()
{
    /**
     * Задание 1. "Старые" потоковые функции стандартной библиотеки.
     *
     * Эти функции использовались в языке C. Если вы будете писать программы на
     * нем, вам придется использовать их вместо std::cin и std::cout.
     */

    /**
     * Задание 1.1.
     *
     * С помощью функции scanf сформируйте три коэффициента: A,B,C.
     */
    {
        int A, B, C;
        printf("Введите коэффициенты A B C: ");
        scanf("%d %d %d", &A, &B, &C);

        printf("Вы ввели: A = %d, B = %d, C = %d \n", A, B, C);
        /**
         * Задание 1.2.
         *
         * Выведите (красиво!) таблицу значений y=A*x*x + B*x + C при изменении x в
         * диапазоне -2 до +2 с шагом 0.5
         */
        printf(" ______________________\n");
        printf("|   x \t | \t   y\n");
        for (double x = -2; x <= 2; x += 0.5)
        {
            double y = A * x * x + B * x + C;
            printf("|%.2f \t | \t %.2f \n", x, y);
        }
    }
    /**
     * Задание 2. Указатели на функции.
     */

    /**
     * Задание 2.1. Указатель на функцию. "Калькулятор".
     *
     * Напишите функции:
     * 1. add - принимает два значения double и возвращает сумму этих значений;
     * 2. sub- принимает два значения double и возвращает разность этих
     *    значений;
     * 3. mul - аналогично для умножения;
     * 4. div - аналогично для деления;
     * 5. а для возведения в степень можете использовать функцию стандартной
     *    библиотеки - pow().
     *
     * Подсказка 1: прототип функции находится в <cmath>.
     * Подсказка 2: стандартная библиотека предоставляет несколько
     * перегруженных вариантов этой функции, а Вам потребуется сформировать
     * указатель на double pow(double, double).
     *
     * Предоставьте пользователю следующую возможность:
     *
     * - пока пользователь хочет пользоваться услугами вашего калькулятора, он
     *   может вводить два значения и знак операции а вы выводите результат.
     * - результат получаете посредством вызова соответствующей вашей функции
     *   по указателю.
     * - предусмотрите возможность ввода непредусмотренного знака операции.
     */
    {
        double first_number;
        double second_number;

        double (*operation)(double, double);
        char op_symbol;

        printf("\n <<Калькулятор>> начал работу. \n");
        printf("\n Полный список операций: \n");
        print_math_operations();

        while (true)
        {
            printf("\n Введите 2 числа и символ операции. \n");
            getchar(); // Для отчистки символа
            scanf("%lf %lf %c", &first_number, &second_number, &op_symbol);

            if (op_symbol == 'q') // Выход из калькулятора
                break;

            bool show_result = true;

            switch (op_symbol)
            {
            case '+':
                operation = add;
                break;
            case '-':
                operation = sub;
                break;
            case '*':
                operation = mul;
                break;
            case '/':
                operation = div;
                break;
            case '^':
                operation = pow;
                break;

            default:
                printf("Данной операции нет в списке. Вот полный список операций: \n");
                print_math_operations();
                show_result = false;
                break;
            }
            if (show_result)
            {
                double result = operation(first_number, second_number);

                printf("\t Результат: %lf \n", result);
            }
        }
    }

    /**
     * Задание 2.2. Указатель на функцию в качестве аргумента.
     *
     * Дана заготовка функции сортировки любых объектов - sort.
     *
     * Функция принимает следующие параметры:
     * 1. указатель на первый сортируемый элемент
     * 2. количество сортируемых элементов
     * 3. размер элемента в байтах
     * 4. указатель на функцию перестановки элементов
     * 5. указатель на функцию сравнения элементов
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите функцию перестановки двух целых значений - swap_int, которая
     * принимает два void указателя и меняет значения местами.
     *
     * Напишите функцию сравнения двух целых значений - CmpInt, которая
     * принимает два void указателя и возвращает int результат сравнения:
     * <0 - первый элемент меньше, чем второй;
     * =0 - равны;
     * >0 - первый элемент больше, чем второй.
     *
     * Используйте эти функции в функции сортировки.
     */
    {
        int nAr[] = {5, 1, 10, 8}; // массив для сортировки
        int nTotal = 4;            // количество элементов в массиве

        /** Печать исходного массива */
        printf("Исходный массив: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%d ", nAr[i]);
        }
        printf("\n");

        sort(reinterpret_cast<char *>(&nAr[0]), nTotal, sizeof(int),
             swap_int, cmp_int);

        /** Печать результатов сортировки */
        printf("Массив после сортировки: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%d ", nAr[i]);
        }
        printf("\n\n");
    }

    /**
     * Задание 2.2.2.
     *
     * По аналогии с заданием 2.2.1 напишите функцию swap_double и cmp_double,
     * и вызовите функцию sort для сортировки вещественных значений.
     */
    {
        double dAr[] = {5.5, 5.1, 10, 8};
        int nTotal = 4;

        printf("Исходный массив double: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%lf ", dAr[i]);
        }
        printf("\n");

        sort(reinterpret_cast<char *>(&dAr[0]), nTotal, sizeof(double),
             swap_double, cmp_double);

        printf("Отсортированный массив double: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%lf ", dAr[i]);
        }
        printf("\n\n");
    }

    /**
     * Задание 2.2.3.
     *
     * По аналогии с 2.2.1 создайте вспомогательные функции - swap_str и
     * cmp_str и вызовите функцию sort для сортировки массива указателей на
     * строки.
     */

    {
        const char *arStr[] = {"QQQ", "SDF", "ABC"};
        int nTotal = 3;

        printf("Исходный массив строк: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%s ", arStr[i]);
        }
        printf("\n");

        sort(reinterpret_cast<char *>(&arStr[0]), nTotal, sizeof(char *),
             swap_str, cmp_str);

        printf("Массив строк после сортировки: ");
        for (int i = 0; i < nTotal; i++)
        {
            printf("%s ", arStr[i]);
        }
        printf("\n\n");
    }

    /**
     * Задание 2.3. Массивы указателей на функцию.
     *
     * Напишите функции для работы с массивом:
     *
     * 1. print_max - печатает максимальный элемент;
     * 2. print_min - печатает минимальный элемент;
     * 3. sort_asc - сортирует по возрастанию и выводит на печать;
     * 4. sort_desc - сортирует по убыванию и выводит на печать.
     *
     * У всех эти функций должна быть одинаковая сигнатура. Объявите, два
     * массива: массив указателей на функции 1-4 и массив указателей на строки
     * с описанием этих функций.
     *
     * Реализуйте меню для пользователя: выведите нумерованный список имен
     * функций (из второго массива), примите от пользователя номер функции,
     * после чего вызовите функцию для какого-нибудь массива.
     */

    {
        const char *descriptions[] = {
            "1. Вывести максимальный элемент массива",
            "2. Вывести минимальный элемент массива",
            "3. Отсортировать массив по возрастанию",
            "4. Отсортировать массив по убыванию",
            "Для выхода из программы введите <q>"};

        char opNumber;
        void (*operation)(double *, int);
        double arr[] = {9.321, 6.17, 3.1, 3.777};
        int size = sizeof(arr) / 8;

        while (true)
        {
            printf("Список действий над массивом: \n");
            for (int i = 0; i < 5; i++)
            {
                printf("%s\n", descriptions[i]);
            }
            printf("\n Введите номер действия для выполнения:\n");

            scanf(" %c", &opNumber);

            if (opNumber == 'q')
                break;

            switch (opNumber)
            {
            case '1':
                operation = print_max;
                break;
            case '2':
                operation = print_min;
                break;
            case '3':
                operation = sort_asc;
                break;
            case '4':
                operation = sort_desc;
                break;
            default:
                printf("Такой команды нет в списке!\n");
                break;
            }

            operation(arr, size);
            printf("---------------------------\n");
        }
    }

    /**
     * Задание 2.4. Метод прямоугольников.
     *
     * Напишите функцию integrate, которая бы принимала:
     * 1. указатель на интегрируемую функцию, которая принимает double и
     *    возвращает double;
     * 2. нижнюю границу интегрирования (вещественное число);
     * 3. верхнюю границу интегрирования (вещественное число);
     * 4. количество отрезков, на которых будет вычисляться функция.
     *
     * Функция должна возвращать численное значение определенного интеграла,
     * полученного методом прямоугольников.
     *
     * Проверьте функцию на разных вещественных функциях (линейных, параболах,
     * exp, sin) и сравните полученные результаты с теоретическими.
     */
    {
        const char *function_equation[] = {"x^2", "sin(x)", "e^x", "3x + 8"};

        double (*functions[])(double) = {square_function, sin_function,
                                         exp_function, linear_function};

        double a = 0; // Нижняя граница
        double b = 2; // Верхняя граница
        int n = 50;

        for (int i = 0; i < 4; i++)
        {
            double result = integrate(functions[i], a, b, 10);
            printf("Интеграл ");
            printf("%s", function_equation[i]);
            printf(" равен: %lf\n", result);
        }

        printf("\n");
    }
    // Совпадает с теоретическими
    /**
     * Задание 3. Структуры С.
     */

    /**
     * Задание 3.1. Структура Book.
     */

    /**
     * Задание 3.1.1.
     *
     * Объявите структуру Book, описывающую книгу (автор, заглавие, год
     * издания, цена, категория…).
     *
     * Подумайте: какого типа могут быть поля структуры.
     * Подсказка: объявление структуры рекомендуется выносить в заголовочный
     * файл.
     */

    /**
     * Задание 3.1.2.
     *
     * Создайте разными способами (глобальный, локальный, статический,
     * динамический) экземпляры (объекты) типа Book (без инициализации).
     *
     * Определите - сколько памяти отводит компилятор под каждый такой объект.
     *
     * Как инициализируются (или не инициализируются) поля структуры?
     *
     * Подумайте: от чего зависит объем выделяемой памяти?
     */

    {
        Book localBook;

        static Book staticBook;

        Book *dynamicBook = new Book;

        // Для статических и глобальных переменных Book будет инициализировано 0.
        // Для локальных и динамический переменных Book не будет инициализировано

        cout << "Размер объекта Book: " << sizeof(Book) << " байт" << std::endl
             << std::endl;

        /**
         * Задание 3.1.3.
         *
         * Заполните поля созданных объектов.
         *
         * Замечание: если для хранения строки используется массив, необходимо
         * предусмотреть "защиту" от выхода за границы массива.
         */
        change_string_field("Лев Толстой", localBook.author);
        change_string_field("Война и мир", localBook.title);
        change_string_field("Роман", localBook.category);
        localBook.price = 500;
        localBook.year = 1867;

        /**
         * Задание 3.1.4.
         *
         * Напишите функцию, выводящую на экран реквизиты книги.
         *
         * Подумайте: как эффективнее передавать экземпляр Book в функцию.
         *
         * Для вывода на консоль используйте функцию стандартной библиотеки printf.
         */
        printf("Информация о книге:\n");
        printBook(localBook);

        printf("\n");

        editBook(localBook);

        printBook(localBook);

        delete[] localBook.author;
        delete[] localBook.category;
        delete[] localBook.title;
        /**
         * Задание 3.1.5.
         *
         * Напишите функцию для формирования полей структуры. Для ввода используйте
         * функцию стандартной библиотеки scanf.
         *
         * Замечание: неплохо заложить в такую функцию возможность проверки
         * корректности введенного значения, например, год издания не может быть
         * меньше, чем... (год появления письменности), категорию пользователь должен
         * выбирать из существующих, цена не может быть отрицательной...
         *
         * Кроме этого необходимо проверить и ошибки другого рода: программа
         * ожидает число, а пользователь ввел случайно букву.
         */
        delete dynamicBook;
    }
    /**
     * Задание 3.2. Матричные операции.
     */

    /**
     * Задание 3.2.1.
     *
     * Задайте структуру Matrix, которая будет представлять вещественную матрицу
     * размера MxN из линейной алгебры.
     *
     * Это определение и связанные с ними функции определите в отдельной паре
     * файлов: matrix.h и matrix.cpp.
     */

    /**
     * Задание 3.2.2.
     *
     * Создайте набор базовых функций для работы с этой структурой:
     *
     * - void m_zero(Matrix *A, int m, int n) - инициализация матрицы размера m
     *   на n нулями;
     * - void m_id(Matrix *A, int n) - инициализация единичной матрицы n на n;
     * - void m_free(Matrix *A) - очистка памяти, используемой для матрицы;
     * - void m_copy(const Matrix *src, Matrix *dst) - копирование данных
     *   матрицы src в матрицу dst.
     * - int m_width(const Matrix *A) - ширина матрицы A;
     * - int m_height(const Matrix *A) - высота матрицы A;
     * - double m_get(const Matrix* A, int i, int j) - получение i,j-того
     *   элемента матрицы;
     * - void m_set(Matrix *A, int i, int j, double value) - установка i,j-того
     *   элемента матрицы.
     */

    /**
     * Задание 3.2.3.
     *
     * Реализуйте набор операций из линейной алгебры:
     *
     * - int m_add(Matrix *A, const Matrix *B) - если A и B одинакового
     *   размера, то прибавляет к A значения B и возвращает 0; иначе возвращает
     *   1.
     * - void m_neg(Matrix *A) - заменяет все элементы матрицы A на
     *   противоположные.
     * - int m_mult(const Matrix *A, const Matrix *B, Matrix *dst) - умножает
     *   матрицу A на матрицу B и сохраняет результат в dst. Если размеры
     *   матрицы не позволяют умножить матрицы, функция возвращает 1, иначе 0.
     */

    /**
     * Задание 3.2.4.
     *
     * С помощью полученного функционала реализуйте матричное вычисление чисел
     * Фибоначчи. Делается это с помощью такой формулы:
     *
     * /  F[n]  \ = / 1  1 \ * / F[n-1] \
     * \ F[n-1] /   \ 1  0 /   \ F[n-2] /
     *
     * Задайте матрицу в центре и матрицу-вектор с двумя первыми числами
     * Фибоначчи: 1 и 0. Выполняйте эту формулу итеративно и выведите первые 40
     * чисел Фибоначчи.
     */

    Matrix vector; // Создание вектор матрицы
    m_zero(&vector, 1, 2);

    m_set(&vector, 0, 0, 1);

    Matrix M; // Создание центральной матрицы
    m_zero(&M, 2, 2);
    m_set(&M, 0, 0, 1);
    m_set(&M, 0, 1, 1);
    m_set(&M, 1, 0, 1);

    int fib_count = 40;
    for (int i = 0; i < fib_count; i++)
    {
        Matrix temp;
        m_zero(&temp, vector.height, M.width);

        int isSuccess = m_mult(&vector, &M, &temp);
        if (isSuccess != 0)
        {
            printf("\nПроизошла ошибка при умножении матриц!\n");
            m_free(&temp);
            m_free(&vector);
            m_free(&M);
            return 1;
        }
        m_copy(&temp, &vector);

        m_free(&temp);
    }
    printf("\nЧисло фибаначчи под номером %d равно: %d.\n",
           fib_count, int(m_get(&vector, 0, 0)));

    m_free(&vector);
    m_free(&M);

    return 0;
}
